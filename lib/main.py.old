#!/usr/bin/python3
# -*- coding: utf-8; tab-width: 4; indent-tabs-mode: t -*-

import os
import uuid
import pickle
import datetime
import subprocess
from gi.repository import GLib
from gbs_util import GbsUtil


class GbsClient:

    def __init__(self):
        self.uuid = None
        self.name = None
        self.ip = None
        self.lastLogin = None
        self.rootDir = None
        self.timeoutHandler = None
        self.rsyncProc = None
        self.rsyncPort = None
        self.sshProc = None
        self.sshPort = None


class GbsClientData:

    def __init__(self):
        self.uuid = None
        self.name = None
        self.lastLogin = None


class GbsMain:

    def __init__(self):
        self.param = GbsParam()
        self.clientDict = dict()
    
    def run_app(self):
        parseResult = self._parseArgs()

        # initialize GbsParam
        if parseResult.pid_file is not None:
            self.param.pidFile = parseResult.pid_file
        self.param.disposeFlag = 0
        self.param.logLevel = parseResult.debug_level

        try:
            # create directory
            GbsUtil.mkDir(self.param.logDir)
            GbsUtil.mkDirAndClear(self.param.runDir)
            self.param.tmpDir = tempfile.mkdtemp(prefix="gentoo-build-server-")
        
            # set logging parameter
            logging.getLogger().addHandler(logging.StreamHandler(sys.stderr))
            logging.getLogger().setLevel(GbsUtil.getLoggingLevel(self.param.logLevel))

            # start web server
            self.appRestfulApi = Flask(__name__)
            self.appRestfulApi.run()
        except Exception as e:
            logging.exception(e)
            raise
        finally:
            # shouldn't remove log directory
            if param.tmpDir is not None and os.path.exists(param.tmpDir):
                shutil.rmtree(param.tmpDir)
            if os.path.exists(param.runDir):
                shutil.rmtree(param.runDir)
            logging.shutdown()
    
    def _parseArgs():
        argParser = argparse.ArgumentParser()
        argParser.add_argument("--pid-file", dest='pid_file', help="Specify location of a PID file.")
        argParser.add_argument("-d", "--debug-level", dest='debug_level',
                            choices=['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'], default="WARNING",
                            help="Set output debug message level")
        return argParser.parse_args()
    

    def clientLogin(self, clientUuid, clientName, clientIp):
        if clientUuid is not None and not self.clientExists(clientUuid):
            raise Exception("the specified client %s does not exist" % (clientUuid))

        # create client object
        client = GbsClient()
        if clientUuid is not None:
            client.uuid = clientUuid
        else:
            client.uuid = uuid.uuid4()
        if clientName is not None:
            client.name = clientName
        else:
            client.name = ""
        client.ip = clientIp
        client.lastLogin = datetime.now()
        client.rootDir = os.path.join(self.param.varDir, clientUuid)

        # record client in database
        self._saveClientToDb(client)

        try:
            # create client root directory
            if not os.path.exists(client.rootDir):
                os.makedirs(client.rootDir)

            # set up rsync server
            client.rsyncPort = GbsUtil.getFreeTcpPort()
            client.rsyncProc = self._runRsyncDaemon(client)

            # set up ssh server
            client.sshPort = GbsUtil.getFreeTcpPort()
            client.sshProc = self._runSshServer(client)

            # add timeout handler
            client.timeoutHandler = GLib.timeout_add_seconds(self.param.clientTimeoutInterval, self._clientTimeoutCallback, client)

            # record client
            self.clientDict[clientUuid] = client
            return client
        except:
            if client.timeoutHandler is not None:
                GLib.source_remove(client.timeoutHandler)
            if client.sshProc is not None:
                client.sshProc.terminate()
                client.sshProc.wait()
            if client.rsyncProc is not None:
                client.rsyncProc.terminate()
                client.rsyncProc.wait()
            raise

    def clientLogout(self, client):
        # delete client object
        del self.clientDict[client.uuid]

        GLib.source_remove(client.timeoutHandler)

        try:
            client.sshProc.terminate()
            client.sshProc.wait()
        except:
            pass

        try:
            client.rsyncProc.terminate()
            client.rsyncProc.wait()
        except:
            pass

    def clientResetTimeout(self, client):
        GLib.source_remove(client.timeoutHandler)
        client.timeoutHandler = GLib.timeout_add_seconds(self.param.clientTimeoutInterval, self._clientTimeoutCallback, client)

    def clientExists(self, clientUuid):
        if not os.path.exists(os.path.join(self.param.varDir, clientUuid)):
            return False
        return True

    def _clientTimeoutCallback(self, client):
        self.clientLogout(client)
        return False

    def _runRsyncDaemon(self, client):
        # generate configuration file
        cfgf = os.path.join(self.param.tmpDir, "%s-rsyncd.conf" % (client.uud))
        with open(cfgf, "w") as f:
            f.write("[main]\n")
            f.write("path = %s\n" % (client.rootDir))
            f.write("read only = no\n")
            f.write("hosts allow = %s\n" % (client.ip))

        # run rsync process
        cmd = ""
        cmd += "/usr/bin/rsync "
        cmd += "--daemon --no-detach "
        cmd += "--config=%s " % (cfgf)
        cmd += "--port=%d " % (client.rsyncPort)
        cmd += "> %s/%s-rsync.out 2>&1" % (self.param.tmpDir, client.uuid)
        proc = subprocess.Popen(cmd, shell=True, universal_newlines=True)

        return proc

    def _runSshServer(self, client):
        # generate configuration file
        # cfgf = os.path.join(self.param.tmpDir, "%s-sshd.conf" % (client.uud))
        # with open(cfgf, "w") as f:
        #     pass

        # run sshd process
        cmd = "/usr/sbin/sshd -D -p %d " % (client.sshPort)
        proc = subprocess.Popen(cmd, shell=True, universal_newlines=True)

        return proc

    def _saveClientToDb(self, client):
        ret = pickle.load(self.param.clientDataFile)
        if client.uuid in ret:
            ret[client.uuid].name = client.name
            ret[client.uuid].lastLogin = client.lastLogin
        else:
            obj = GbsClientData()
            obj.uuid = client.uuid
            obj.name = client.name
            obj.lastLogin = client.lastLogin
            ret[client.uuid] = obj
        pickle.dump(ret, self.param.clientDataFile)

    def _loadClientDataFromDb(self, clientUuid):
        ret = pickle.load(self.param.clientDataFile)
        return ret.get(clientUuid)
